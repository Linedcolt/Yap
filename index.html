<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Yap</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; margin: 0; height: 100vh; display:flex; }
    aside { width: 300px; border-right:1px solid #eee; padding: 16px; box-sizing:border-box; }
    main { flex:1; display:flex; flex-direction:column; }
    .room-list { max-height: 40vh; overflow:auto; margin-bottom: 12px; }
    .messages { flex:1; padding: 16px; overflow:auto; background:#fafafa; }
    .msg { margin-bottom:8px; }
    footer { display:flex; padding:8px; border-top:1px solid #eee; }
    input, button, textarea { font:inherit; }
    .small { font-size: 0.9rem; color:#666 }
    .invite { word-break:break-all; background:#f3f6ff; padding:8px; border-radius:6px; margin-top:8px; }
  </style>
</head>
<body>
  <aside>
    <h3>Rooms</h3>
    <div>
      <input id="newRoomName" placeholder="New room name" />
      <button id="createRoomBtn">Create</button>
    </div>
    <div class="room-list" id="rooms"></div>
    <div style="margin-top:12px">
      <div class="small">Current User</div>
      <input id="username" placeholder="your name" />
    </div>
    <div id="inviteBox" style="margin-top:12px"></div>
  </aside>

  <main>
    <header style="padding:12px;border-bottom:1px solid #eee">
      <strong id="roomTitle">No room selected</strong>
    </header>

    <div class="messages" id="messages"></div>

    <footer>
      <input id="messageInput" style="flex:1" placeholder="Type a message..." />
      <button id="sendBtn">Send</button>
    </footer>
  </main>

  <!-- UMD build of supabase-js -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // ====== CONFIG: replace with your Supabase values ======
    const SUPABASE_URL = 'https://qtjgoejrrcwibpvtgbss.supabase.co'; // <- replace
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF0amdvZWpycmN3aWJwdnRnYnNzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzEwNjI0NTIsImV4cCI6MjA4NjYzODQ1Mn0.n2wVMIlwz1MbFOxctbuSQGfL36NGuoaOqKslZHrQQAw';            // <- replace
    // ======================================================

    // create client (UMD exports a global 'supabase' object)
    const { createClient } = supabase;
    const sb = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // UI refs
    const roomsEl = document.getElementById('rooms');
    const createRoomBtn = document.getElementById('createRoomBtn');
    const newRoomName = document.getElementById('newRoomName');
    const usernameInput = document.getElementById('username');
    const messagesEl = document.getElementById('messages');
    const roomTitle = document.getElementById('roomTitle');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const inviteBox = document.getElementById('inviteBox');

    let currentRoom = null;
    let channel = null; // realtime channel subscription handle

    // utils
    function el(tag, text, cls){ const e=document.createElement(tag); if(text) e.textContent=text; if(cls) e.className=cls; return e; }

    // load rooms
    async function loadRooms(){
      const { data, error } = await sb.from('rooms').select('*').order('created_at', { ascending: false }).limit(100);
      if (error) { console.error(error); return; }
      roomsEl.innerHTML = '';
      data.forEach(r => {
        const b = el('div', r.name + ' ');
        const joinBtn = document.createElement('button');
        joinBtn.textContent = 'Join';
        joinBtn.onclick = () => joinRoom(r);
        b.appendChild(joinBtn);
        roomsEl.appendChild(b);
      });
    }

    // create room (with invite_code)
    async function createRoom(){
      const name = newRoomName.value.trim();
      if(!name) return alert('Name required');
      // simple random token:
      const invite_code = crypto.randomUUID();
      const { data, error } = await sb.from('rooms').insert([{ name, invite_code }]).select().single();
      if (error) return console.error(error);
      newRoomName.value = '';
      await loadRooms();
      // join newly created room
      joinRoom(data);
    }

    // build invite link
    function inviteLinkFor(room){
      // using query params: ?rid=<room.id>&token=<invite_code>
      const url = new URL(window.location.href);
      url.searchParams.set('rid', room.id);
      if (room.invite_code) url.searchParams.set('token', room.invite_code);
      return url.toString();
    }

    // join a room: shows messages and subscribes to realtime inserts
    async function joinRoom(room){
      // teardown existing channel if any
      if(channel) {
        try { await sb.removeChannel(channel); } catch(e){ /* ignore */ }
        channel = null;
      }

      currentRoom = room;
      roomTitle.textContent = room.name;
      inviteBox.innerHTML = '';
      const inv = el('div', 'Invite link:', 'small');
      const linkdiv = el('div', inviteLinkFor(room), 'invite');
      inviteBox.appendChild(inv);
      inviteBox.appendChild(linkdiv);

      // load last messages
      const { data, error } = await sb.from('messages').select('*').eq('room_id', room.id).order('created_at', { ascending: true }).limit(200);
      if (error){ console.error(error); return; }
      messagesEl.innerHTML = '';
      data.forEach(addMessageToUI);

      // subscribe to realtime INSERTS on messages for this room
      channel = sb.channel('room-' + room.id)
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages', filter: 'room_id=eq.' + room.id },
          (payload) => {
            addMessageToUI(payload.new);
          })
        .subscribe();
    }

    function addMessageToUI(msg){
      const d = el('div', '', 'msg');
      const time = new Date(msg.created_at).toLocaleTimeString();
      d.innerHTML = `<strong>${escapeHtml(msg.username)}</strong> <span class="small">${time}</span><div>${escapeHtml(msg.content)}</div>`;
      messagesEl.appendChild(d);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // send message
    async function sendMessage(){
      if(!currentRoom) return alert('Join a room first');
      const content = messageInput.value.trim();
      const username = (usernameInput.value || 'Anon').trim();
      if(!content) return;
      const { error } = await sb.from('messages').insert([{ room_id: currentRoom.id, username, content }]);
      if (error) {
        console.error(error);
        alert('Error sending message');
      } else {
        messageInput.value = '';
      }
    }

    // small helper
    function escapeHtml(s){ return (''+s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

    // parse URL to auto-join room if invite present
    async function tryJoinFromUrl(){
      const params = new URLSearchParams(window.location.search);
      const rid = params.get('rid');
      const token = params.get('token');
      if (!rid) return;
      // fetch room: if invite_code exists, check token matches (simple client-side check)
      const { data, error } = await sb.from('rooms').select('*').eq('id', rid).single();
      if (error || !data) return console.warn('room not found or error', error);
      if (data.invite_code && token && token !== data.invite_code){
        alert('Invalid invite token');
        return;
      }
      // join
      joinRoom(data);
    }

    // attach handlers
    createRoomBtn.onclick = createRoom;
    sendBtn.onclick = sendMessage;
    messageInput.addEventListener('keydown', (e)=> { if(e.key === 'Enter') sendMessage(); });

    // initial load
    (async ()=> {
      await loadRooms();
      await tryJoinFromUrl();
    })();

    // refresh room list periodically (or you can add a subscription to rooms table)
    setInterval(loadRooms, 15000);
  </script>
</body>
</html>
